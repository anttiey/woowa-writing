# 글을 시작하며

클로저는 많은 개발자들이 자바스크립트를 배우는 과정에서 가장 어렵고 복잡하다고 느끼는 개념 중 하나입니다. 클로저를 완벽하게 이해하기 위해서는 자바스크립트의 동작 원리와 스코프 체인을 깊이 다루어야 하기 때문에 악명이 높죠. 클로저는 함수의 내부에서 외부 함수의 변수를 참조할 수 있도록 하는 메커니즘으로, 자바스크립트의 비동기 처리나 콜백 함수에서 상당히 중요한 역할을 합니다.

클로저는 단순히 자바스크립트의 어려운 개념에 그치지 않고 함수형 프로그래밍의 기본 개념 중 하나로 널리 사용됩니다. 함수형 프로그래밍은 순수 함수를 기반으로 프로그램을 구성하는 프로그래밍 패러다임입니다. 따라서 클로저를 이해하는 것은 함수형 프로그래밍의 핵심을 이해하는 것과 같습니다.

이 글에서는 클로저가 무엇인지, 어떻게 작동하는지, 그리고 어떻게 활용할 수 있는지 차근차근 다루고자 합니다. 글을 다 읽으실 때쯤에는 여러분 모두가 클로저 마스터가 되어 있으리라 기대합니다.

<br />

# **1. 클로저의 정의**

클로저는 **함수와 그 함수가 선언된 렉시컬 환경의 조합**을 의미합니다. 다시 말해서 클로저는 함수가 선언될 당시의 외부 스코프에 접근할 수 있는 함수입니다.

여기서 **렉시컬 환경**과 **외부 스코프** 같은 용어가 낯설게 느껴질 수 있습니다. 이 개념들은 자바스크립트의 기본적인 동작 원리와 밀접하게 연관되어 있습니다. 이를 먼저 이해하면 클로저를 보다 쉽게 파악할 수 있을 것입니다.

<br />

# **2. 클로저를 이해하기 위한 사전 지식**

## **2-1. 렉시컬 환경**

렉시컬(Lexical)이라는 단어는 사전적으로 ‘어휘적' 또는 '문맥적'이라는 의미를 지닙니다. 이를 바탕으로 확장해 보면 렉시컬 환경이란 함수가 선언될 당시의 **맥락을 기억하는 환경**이라고 할 수 있습니다.

렉시컬 환경은 함수 안에서 사용할 수 있는 요소를 저장하는 공간입니다. 자바스크립트 엔진은 렉시컬 환경을 통해 함수가 참조할 수 있는 변수를 관리합니다. 중요한 점은 함수가 선언될 때 그 주변의 스코프 정보가 함께 저장된다는 것입니다. 이렇게 저장된 정보는 함수가 나중에 실행될 때도 그대로 유지되어 함수가 언제 어디서 실행되더라도 참조할 수 있게 됩니다.

> 스코프에 대한 자세한 설명은 2-2 파트에서 다루고 있습니다

렉시컬 환경은 두 가지 중요한 섹션으로 구분할 수 있습니다.

![렉시컬 환경 이미지](./image_1.png)

### **환경 레코드**

환경 레코드는 함수가 선언되었을 때 존재하는 변수, 상수, 함수 등의 정보를 저장하는 객체입니다. 현재 스코프 내에서 사용할 수 있는 모든 식별자를 기록하고 관리합니다.

예를 들어, 함수 내부에서 `const x = 10;` 과 같이 변수가 선언되었다면 환경 레코드에는 `x = 10` 이라는 정보가 저장됩니다.

### **외부 렉시컬 환경에 대한 참조**

렉시컬 환경은 상위 스코프에 대한 참조 정보를 담고 있습니다. 이 참조 정보를 통해 현재 함수가 선언된 스코프보다 상위에 있는 스코프에서 선언된 변수에도 접근할 수 있게 됩니다. 이러한 참조는 스코프 체인을 형성하여 함수가 현재 스코프에서 변수를 찾지 못할 때 상위 스코프로 이동하며 변수를 계속해서 찾을 수 있게 해줍니다.

## **2-2. 렉시컬 스코프**

렉시컬 스코프란 **선언된 위치에 따라** 함수가 참조할 수 있는 변수의 범위가 결정되는 규칙을 말합니다. 자바스크립트는 렉시컬 스코핑 방식을 따르기 때문에 함수가 어디서 호출되었는지가 아니라, **어디서 선언되었는지에 따라** 함수가 접근할 수 있는 변수가 결정됩니다.

다음 예시를 살펴 봅시다.

```jsx
const x = 1;

function 외부_함수() {
  const x = 10;
  내부_함수();
}

function 내부_함수() {
  console.log(x);
}

외부_함수(); // 1 출력
내부_함수(); // 1 출력
```

위 예시에서 `외부_함수` 와 `내부_함수` 는 모두 `1` 을 출력합니다. `외부_함수` 안에서 `내부_함수` 가 호출되고 있으므로, `내부_함수` 가 `외부_함수` 의 `x = 10` 을 참조해 `10` 을 출력할 것이라고 생각할 수 있습니다. 하지만 자바스크립트에서는 함수가 어디서 선언되었는지에 따라 접근할 수 있는 변수가 결정된다고 했습니다. `내부_함수` 는 전역에서 선언되었기 때문에 전역 스코프의 `x = 1` 을 참조해 `1` 을 출력합니다. 따라서 `외부_함수` 안의 `x = 10` 은 무시됩니다.

마찬가지로 `내부_함수` 를 직접 호출할 때도 전역 스코프에서 `x = 1` 을 찾아 `1` 을 출력합니다.

즉 자바스크립트는 함수가 호출되는 위치와 상관없이 선언된 위치를 바탕으로 상위 스코프를 결정하며, 이렇게 결정된 스코프를 통해 변수를 참조합니다.

<br />

# **3. 클로저의 기본 동작 원리**

앞에서 설명한 것처럼 클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합을 의미합니다.

![함수 내부 슬롯 이미지](./image_2.png)

구체적으로 설명하자면 자바스크립트에서 함수는 내부적으로 `[[Environment]]` 라는 내부 슬롯에 렉시컬 환경에 대한 참조를 저장합니다. 이 `[[Environment]]` 내부 슬롯을 통해 함수가 나중에 호출되더라도 해당 함수가 선언될 당시의 외부 렉시컬 환경에 접근할 수 있는 참조를 유지하게 됩니다.

이러한 메커니즘 덕분에 함수는 외부 함수의 변수를 기억하고 접근할 수 있으며, 이렇게 함수가 렉시컬 환경과 결합되는 개념이 바로 **클로저**입니다.

자바스크립트 엔진은 클로저가 외부 변수에 대한 참조를 가지고 있는지 확인하여 해당 변수를 메모리에서 해제하지 않고 유지합니다. 이렇게 클로저는 외부 함수의 변수를 메모리에 남겨두어 상태를 유지하거나 데이터를 은닉하는 데 활용될 수 있습니다.

<br />

# **4. 클로저의 기본 예시**

```jsx
function 케이크_상자() {
  let 케이크_수 = 0;

  const 케이크_먹기 = function () {
    케이크_수++;
    return `케이크를 ${케이크_수}개 먹었어요!`;
  };

  return 케이크_먹기;
}

const 케이크 = 케이크_상자();

console.log(케이크()); // '케이크를 1개 먹었어요!' 출력
console.log(케이크()); // '케이크를 2개 먹었어요!' 출력
```

위 코드는 클로저의 개념을 잘 보여주는 기본적인 예시입니다.

`케이크_상자` 함수는 `케이크_수` 지역 변수를 정의하고 있습니다. 이 변수는 `케이크_상자` 함수 내에서만 유효한 지역 변수지만 내부 함수인 `케이크_먹기` 함수에서 참조됩니다. 이때 `케이크_먹기` 함수는 클로저로 외부 함수가 종료된 후에도 `케이크_수` 변수를 계속 참조할 수 있습니다.

`케이크_상자` 함수가 호출되면 내부 함수 `케이크_먹기` 함수가 반환됩니다. `케이크_먹기` 함수는 내부 `[[Environment]]` 슬롯에 `케이크_상자` 함수의 렉시컬 환경을 저장하여 `케이크_수` 변수의 값을 계속 참조하고, 호출될 때마다 증가된 값을 반환합니다.

이렇게 클로저로 인해 외부 함수의 변수가 메모리에 유지되어 상태가 누적됩니다.

<br />

# **5. 자바스크립트의 클로저**

자바스크립트에서 모든 함수는 **이론적으로 클로저**입니다. 이는 자바스크립트의 함수가 렉시컬 스코프를 따르기 때문에, 선언된 위치의 스코프에 있는 변수를 기억하고 참조할 수 있기 때문입니다.

그러나 실질적으로 **모든 함수가 클로저로 동작하지는 않습니다.** 클로저는 어떠한 함수가 상위 스코프에 선언된 외부 함수의 변수를 참조할 때만 생성됩니다. 다시 말해, 내부 함수가 상위 스코프의 변수에 접근할 필요가 없거나 접근하지 않는다면 그 함수는 클로저로 작동하지 않습니다.

## **5-1. 상위 스코프의 식별자를 참조하지 않는 경우**

함수가 상위 스코프의 변수를 전혀 참조하지 않는다면, 그 함수는 클로저로 작동하지 않습니다. 이 경우 함수는 독립적으로 동작하며 외부 렉시컬 환경을 기억할 필요가 없습니다.

```jsx
function 음료수_가게() {
  const 콜라 = '콜라를 주문했습니다.';
  const 사이다 = '사이다를 주문했습니다.';

  function 오늘의_이벤트() {
    const 무료_리필 = '사장님이 서비스로 한 잔 더 주셨습니다!'; // 내부 변수
    console.log(무료_리필); // 내부 변수만 참조
  }

  return 오늘의_이벤트;
}

const 음료수_주문 = 음료수_가게();
음료수_주문(); // '사장님이 서비스로 한 잔 더 주셨습니다!' 출력
```

위 예시에서 `음료수_가게` 함수 내에 콜라와 사이다라는 변수가 선언되어 있지만, 이 변수들은 내부 함수인 `오늘의_이벤트` 에서 전혀 사용되지 않습니다. `오늘의_이벤트` 함수는 자신의 스코프에 정의된 `무료_리필` 변수만 참조하고 있습니다. 즉 내부 함수가 외부 함수의 변수에 접근하지 않고, 자기 자신의 스코프 안에서만 변수를 관리합니다.

따라서 `오늘의_이벤트` 함수는 외부 함수의 변수를 전혀 사용하지 않기 때문에 클로저로 동작하지 않습니다.

이러한 특성은 자바스크립트 엔진의 최적화 전략과 깊은 관련이 있습니다. 자바스크립트는 가비지 컬렉션을 통해 더 이상 사용되지 않는 변수를 메모리에서 해제합니다. 함수 실행이 종료되면 함수 내부에서 선언된 지역 변수들은 필요하지 않을 때 메모리에서 제거됩니다.

자바스크립트는 함수가 외부 변수를 참조할 때만 상위 스코프의 변수를 메모리에 유지하므로, 클로저가 아닌 함수는 불필요하게 메모리를 점유하지 않습니다. 이로써 메모리 사용을 줄이는 최적화를 수행합니다.

## **5-2. 생명 주기가 외부 함수보다 짧은 경우**

클로저는 내부 함수가 외부 함수의 변수를 참조하고 외부 함수가 종료된 후에도 그 변수를 계속 사용할 수 있을 때 생성됩니다. 반대로 말하면 내부 함수의 생명 주기가 외부 함수보다 짧을 때는 클로저가 형성되지 않습니다.

```jsx
function 음료수_가게() {
  const 콜라 = '콜라를 주문했습니다.';
  const 사이다 = '사이다를 주문했습니다.';

  function 오늘의_이벤트() {
    console.log(콜라);
  }

  오늘의_이벤트(); // 외부 함수가 종료되기 전에 바로 실행
}

음료수_가게();
```

위 예시에서 내부 함수인 `오늘의_이벤트` 함수는 외부 변수 `콜라` 를 참조하지만 외부 함수가 종료되기 전에 즉시 실행됩니다. 따라서 외부 함수가 종료되기 전, 외부 변수에 접근하여 값을 출력한 뒤 실행을 종료하게 됩니다.

`오늘의_이벤트` 함수의 생명 주기는 외부 함수 `음료수_가게` 의 생명 주기보다 짧습니다. 내부 함수는 실행 중에 외부 렉시컬 환경에 접근하지만 이후 외부 함수가 종료되면서 모든 변수가 메모리에서 해제됩니다. 내부 함수가 외부 변수를 참조하는 것은 클로저의 핵심 조건 중 하나이지만 외부 함수 종료 전에 실행이 끝나므로 실질적으로 클로저가 아닙니다.

<br />

# **6. 클로저의 활용 사례**

## **6-1. 데이터 은닉**

클로저를 통해 변수에 직접 접근하지 못하게 하여 데이터를 보호하고 함수 내부에서만 값을 조작할 수 있게 할 수 있습니다.

```jsx
function 은행_계좌(초기_잔액) {
  let 잔액 = 초기_잔액; // 외부에서 접근할 수 없는 내부 변수

  return {
    입금: function (금액) {
      잔액 += 금액;
      console.log(`입금 후 잔액: ${잔액}원`);
    },
    잔액_조회: function () {
      console.log(`현재 잔액: ${잔액}원`);
    },
  };
}

const 내_계좌 = 은행_계좌(10000);
내_계좌.입금(5000);
내_계좌.잔액_조회(); // '현재 잔액: 13000원' 출력
```

위 예시에서 `잔액` 변수는 클로저에 의해 보호되며 외부에서는 직접 접근할 수 없습니다.

`은행_계좌` 함수가 `잔액` 변수를 외부로부터 보호하고 오직 반환된 메서드를 통해서만 조작할 수 있게 합니다. 클로저로 인해 `은행_계좌` 함수가 종료된 후에도 내부 함수에서 `잔액` 변수를 참조할 수 있게 됩니다.

## **6-2. 커링**

커링은 여러 인자를 받는 함수를 분리하여 각 인자를 하나씩 받는 함수 체인으로 만드는 기법입니다. 각각의 함수는 호출될 때마다 인자를 클로저로 캡처하여 나중에 필요한 연산에 사용할 수 있도록 합니다.

```jsx
function 커피_주문(커피_종류) {
  return function (커피_사이즈) {
    return function (커피_옵션) {
      return `${커피_종류}(${커피_사이즈} 사이즈) 주문 완료! ${커피_옵션} 옵션이 선택되었습니다.`;
    };
  };
}

const 아메리카노_주문 = 커피_주문('아메리카노');
const 라지_아메리카노_주문 = 아메리카노_주문('라지');

console.log(라지_아메리카노_주문('샷 추가'));
// '아메리카노(라지 사이즈) 주문 완료! 샷 추가 옵션이 선택되었습니다.' 출력
```

위 예시는 커피를 주문하는 과정을 단계별로 분리하여 각 함수에서 커피의 세부 사항을 하나씩 선택하는 방식으로 구성되어 있습니다.

첫 번째 단계에서는 `커피_주문("아메리카노")` 를 통해 커피 종류를 선택하고, 두 번째 단계인 `아메리카노_주문("라지")` 에서 커피 사이즈를 선택합니다. 마지막으로 `라지_아메리카노_주문("샷 추가")` 에서 추가 옵션을 선택하면, 최종적으로 `아메리카노(라지 사이즈) 주문 완료! 샷 추가 옵션이 선택되었습니다.` 라는 문구가 출력됩니다.

이러한 커링의 장점은 복잡한 함수 호출을 단계별로 처리할 수 있다는 것입니다. 커링을 사용하면 여러 인자를 한꺼번에 받는 대신 각 인자를 하나씩 전달받아 필요한 시점에 호출할 수 있습니다. 이를 통해 유연한 함수 설계가 가능해집니다.

## **6-3. 리액트의 훅**

리액트 훅에서 클로저는 매우 중요한 역할을 합니다. 대표적으로 `useState` 나 `useEffect` 훅에서 클로저는 이전 상태를 기억하고 안전하게 상태를 갱신할 수 있도록 돕습니다.

```jsx
import { useState } from 'react';

function counter() {
  const [count, setCount] = useState(0); // count 변수와 setCount 함수

  const increment = () => {
    setCount((prevCount) => prevCount + 1); // prevCount를 클로저로 기억하고, 상태를 안전하게 업데이트
  };

  return (
    <div>
      <p>현재 카운트: {count}</p>
      <button onClick={increment}>카운트 증가</button>
    </div>
  );
}
```

위 예시에서 `useState` 훅은 `count` 라는 변수를 관리합니다. `setCount` 함수는 클로저로 이전 상태 값인 `prevCount` 를 기억하고 이를 참조하여 새로운 상태 값을 계산합니다.

이와 같이 리액트에서 클로저는 이전 상태 값을 유지하면서도 최신 상태로 안전하게 업데이트할 수 있는 메커니즘을 제공합니다.

<br />

# **7. 클로저의 장단점**

## **7-1. 클로저의 장점**

### **데이터 보호 및 상태 유지**

클로저를 사용하면 외부에서 변수에 직접 접근할 수 없도록 보호할 수 있습니다. 일반적으로 지역 변수는 함수 실행이 종료되면 메모리에서 해제되지만, 클로저에서는 내부 함수가 상위 스코프의 변수를 참조하기 때문에 해당 변수가 메모리에 유지됩니다. 이를 통해 외부에서 변수에 접근할 수 없도록 하면서 안전하게 상태를 유지할 수 있습니다.

### 다양한 함수 설계 패턴

클로저는 다양한 함수 설계 패턴을 구현할 때에도 매우 중요한 역할을 합니다. 클로저를 통해 커링 기법과 같은 설계 방식을 활용할 수 있고, 이벤트 핸들러나 비동기 요청을 처리할 때 특정 시점의 값을 저장하고 나중에 사용할 수 있습니다.

## **7-2. 클로저의 단점**

### 메모리 누수 가능성

클로저는 참조하는 상위 스코프의 변수를 메모리에 계속 유지하기 때문에 잘못 관리하면 메모리 누수가 발생할 수 있습니다. 불필요하게 클로저를 남발하면 메모리 사용량이 증가할 수 있으므로, 이를 방지하기 위해 사용이 끝난 클로저에서 참조를 명시적으로 해제하는 등의 메모리 관리가 필요합니다.

### 디버깅 및 상태 추적의 어려움

클로저의 독특한 특성상 함수 실행 흐름을 따라가며 디버깅하는 과정이 복잡해질 수 있습니다. 특히 클로저가 여러 개 중첩된 경우, 어느 시점에서 상태가 변경되었는지 파악하기 어려워집니다. 클로저는 변수의 생명 주기를 예측하기 어렵게 만들어 의도하지 않은 상태가 형성될 수 있습니다.

<br />

# **글을 마무리하며**

이번 글을 통해 클로저가 무엇인지, 어떻게 작동하는지, 그리고 어떻게 활용할 수 있는지 살펴 보았습니다. 클로저는 자바스크립트에서 제공하는 매우 강력한 기능입니다. 하지만 클로저는 그 강력함에 비례하여 주의 깊게 사용해야 합니다. 불필요하게 남용되거나 메모리 관리가 적절히 이루어지지 않을 경우 메모리 누수와 성능 저하를 초래할 수 있습니다.

따라서 클로저는 필요한 상황에서만 적절히 활용되어야 하며, 이를 통해 얻는 이점과 성능 비용을 신중히 고려해야 합니다. 맹목적으로 클로저를 남발하는 것이 아닌 클로저의 특성과 장단점을 충분히 이해한 후 상황에 맞는 최선의 방법으로 사용하는 것이 그 이점을 최대한 활용하는 길입니다.

여러분의 성공적인 클로저 연구 생활을 기원합니다.

<br />

# 참고 자료

- 모던 자바스크립트 Deep Dive: 자바스크립트의 기본 개념과 동작 원리
- https://www.yalco.kr/@javascript-abyss/12-1/
- https://tc39.es/ecma262/multipage/ordinary-and-exotic-objects-behaviours.html#sec-ecmascript-function-objects
